---
title: "Sequential Testing App"
author: "Merritt Aho"
date: "11/20/2020"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    css: styles.css
    vertical_layout: scroll
runtime: shiny
---
```{r setup, include=FALSE}
library(ggplot2)
library(shinyjs)
library(shiny)
library(gsDesign)
library(formattable)
```

```{r varsAndFunctions, include=FALSE}
reactiveDesignVars <- reactiveValues(fixedn = NULL, seqn = NULL) # All test design ouputs
reactiveResultsVars <- reactiveValues(z = NULL, rslt = NULL, win = NULL) # All analysis outputs
reactTalesNum <- reactiveVal() # Turn "tails" radio button output to number from string

createTest <- function(a,b,c,d,e,f,g,h=NULL) {
      alph = 1 - a/100
      pwr = b/100
      base = c/100
      nonf = d/100
      cvrB = base * (1 + e/100)
      tls1 = f
      k_checks <- g
      upBnd = 3 #upper boundary exponent value (higher is more conservative, typically use 2 or 3)
      lowBnd = 2 #lower boundary exponent values (higher is more conservative, typically use 2 or 3)
      sides = if (tls1 > 1) "two.sided" else "one.sided" 
      testType = if (tls1 > 1) 2 else 4
      cvrA = if (tls1 > 1) base else base * (1 - nonf)
      
      # FIXED SAMPLE ----
      n_fixed = power.prop.test(
        n = NULL,
        p1 = cvrA,
        p2 = cvrB,
        sig.level = alph,
        power = pwr,
        alternative = sides
      )$n

      # 1ST DESIGN ----
      # initital gsDesign object with evenly spaced checkpoints,
      # used to calculate the maximum samples we would require

      design = gsDesign(
        k = k_checks,
        test.type = testType,
        alpha = alph / tls1,
        sfu = sfPower,
        sfupar = upBnd,
        sfl = sfPower,
        sflpar = lowBnd,
        n.fix = n_fixed,
        beta = 1 - pwr,
        delta0 = cvrA,
        delta1 = cvrB
      )
      
      # MAX SAMPLE PER VARIATION ----
      n_sequential = tail(design$n.I, 1)

      # ANALYSIS CHECKPOINTS ----
      #checkpoints <- list()
      multiplier <- 1/k_checks
      checkpoints <- seq(1,k_checks)*multiplier*n_sequential
      
      # If updated checkpoints were passed in based on analyses entered, plug them into the analysis here
      if (!is.null(h)) {
        for (i in 1:length(h)) {
          a <- as.numeric(h[[i]][[1]])
          b <- a - 1
          c <- as.numeric(h[[i]][[3]])
          if (b == 0 || c > checkpoints[b]) {
            checkpoints[a] <- c
          }
        }
      }
      
      # 2ND DESIGN ----
      # Generates updated gsDesign object with chosen checkpoints
      finalDesign <-
        gsDesign(
          k = k_checks,
          test.type = testType,
          alpha = alph / tls1,
          sfu = sfPower,
          sfupar = upBnd,
          sfl = sfPower,
          sflpar = lowBnd,
          n.fix = n_fixed,
          n.I = checkpoints,
          beta = 1 - pwr,
          delta0 = cvrA,
          delta1 = cvrB
        )
      
      
      return(finalDesign)

}

getz <- function (a,b,c,d,e) {
  round(-testBinomial(x1=a, x2=b, n1=c, n2=d, delta0 = e), digits = 2)
}
```

#### Design and execute a frequentist sequential test using this handy calculator.
[Markdown Cheat sheet](https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf)

To do:

* Clean up tails input references
* Better labels for power table
* Better lables for sample size table
* Add results line to boundary table
* Format everything!!!
* Add comments and clean up

```{r quickLoadShortcut}
div(
  div(class = "ql", "Load a prior configuration: "),
  div(class = "ql", textInput("shortcut", NULL, width = "130px")),
  div(class = "ql", actionLink("loadShortcut", label = "Load Shortcut")),
)
uiOutput('fixedLink')
```

```{r quickLoadUtilities, include=FALSE}
# FIXED LINK OUTPUT ----
  output$fixedLink <- renderUI({
    a <- function () {
      b <- ""      
      try ({for (i in 1:length(reactiveResultsVars$rslt)) {
        d <- reactiveResultsVars$rslt[i]
        c <- paste(d[[1]], collapse = "-")
        b <- if (nchar(b) > 1) paste(b,c, sep = ";") else c
      }
      })
      return (b)
    }
    
    div(class="fixedLinkRow",
        "Current configuration shortcut:",
    paste(
      input$alpha,
      input$pwr,
      input$cvra,
      input$mde,
      input$tls,
      input$nonf,
      input$traff,
      input$checknum,
      input$conversions,
      input$dayNum,
      a(),
      sep = ","
    ))
  })
  
# LOAD SHORTCUT ----
  observeEvent(input$loadShortcut, {
    shortcutList <- unlist(strsplit(input$shortcut,","))
    updateNumericInput(session, 'alpha', value = shortcutList[1])
    updateNumericInput(session, 'pwr', value = shortcutList[2])
    updateNumericInput(session, 'cvra', value = shortcutList[3])
    updateNumericInput(session, 'mde', value = shortcutList[4])
    updateNumericInput(session, 'tls', value = shortcutList[5])
    updateNumericInput(session, 'nonf', value = shortcutList[6])
    updateNumericInput(session, 'traff', value = shortcutList[7])
    updateNumericInput(session, 'checknum', value = shortcutList[8])
    updateNumericInput(session, 'conversions', value = shortcutList[9])
    updateNumericInput(session, 'dayNum', value = shortcutList[10])
    r1 <- strsplit(shortcutList[11],";", fixed = TRUE)
    r2 <- r1[[1]]
    r3 <- list()
    r4 <- list()
    for (i in 1:length(r2)) {
      r3 <- strsplit(r2[i],"-",fixed = TRUE)
      r3 <- c(r3[[1]])
      rl <- paste0("checkpoint",r3[1])
      r4[[rl]] <- r3
    }
    reactiveResultsVars$rslt <- r4

  })
```

Row {.tabset data-height=300} 
-----------------------------

### Test Configuration
Enter your desired `confidence level`. This is ($1 - \alpha$) where $\alpha$ is your nominal false positive error rate.

```{r}
numericInput("alpha",
             label = NULL, value = 95, min = 50, max = 99.9, step = 5)

```

Enter power
```{r}
numericInput(
  "pwr",
  label = NULL,
  value = 80,
  min = 1,
  max = 99,
  step = 5
)
```

Minimum detectable effect
```{r}
numericInput(
  "mde",
  label = NULL,
  value = 10,
  min = 0,
  max = 1000,
  step = 1
)
```

### Superiority vs Non-inferiorty
Tails
```{r}
radioButtons("tls",
             NULL,
             choices = list("1-tail test for superiority" = 1, 
                            "2-tail for any difference" = 2,
                            "1-tail test with non-inferiority margin" = 3),
             selected = 1)
```

Non-inferiority margin
```{r}
numericInput("nonf",
             NULL,
             value = 0,
             min = 0,
             max = 50)
```


### Current Traffic
Traffic volume here
```{r}
numericInput(inputId = "traff",
             label = NULL,
             value = 10000,
             step = 1000)
```

Conversions
```{r}
numericInput("conversions", NULL, value=1000, step = 100)
```

How many days of traffic is this (we recommend using 4 weeks minimum)
```{r}
numericInput("dayNum", NULL, value=7, step = 1)
```


Base conversion rate


```{r}
numericInput(
  "cvra",
  label = NULL,
  value = 10,
  min = 1,
  max = 100,
  step = 1
)
```
(calculated conversion rate =
```{r}
textOutput("currentCvr", inline = TRUE)
```
%)

```{r}
output$currentCvr = renderText({input$conversions/input$traff*100})

```


### Inputs help
`Confidence` = the thingy thing

### Advanced
Upper boundary sensitivity
Lower boundary sensitivity
Boundary type

Row {data-height=200}  
-----------------------------

### Planned analyses
* input checkins number
Number of checkins you want to make
```{r}
numericInput(
  "checknum",
  label = NULL,
  min = 2,
  max = 1000,
  value = 4,
  step = 1
)
```


```{r createAndStoreDesign, include=FALSE}
# SEQUENTIAL TEST DESIGN

observeEvent(c(input$alpha, input$pwr, input$cvra, input$nonf, input$mde, input$tls, input$checknum, reactiveResultsVars$rslt),{
  reactiveDesignVars$tls <- as.numeric(input$tls)
  if (is.null(reactiveResultsVars$rslt)) {
    testDesign <- createTest(input$alpha, input$pwr, input$cvra, input$nonf, input$mde, reactiveDesignVars$tls, input$checknum)
  } else  {
    testDesign <- createTest(input$alpha, input$pwr, input$cvra, input$nonf, input$mde, reactiveDesignVars$tls, input$checknum, reactiveResultsVars$rslt)
  }
  reactiveDesignVars$fixedn <- testDesign$n.fix*2
  reactiveDesignVars$seqn <- tail(testDesign$n.I,1)*2
  reactiveDesignVars$pwrplot <- plot.gsDesign(testDesign, plottype = 2)
  reactiveDesignVars$deltaplot <- plot.gsDesign(testDesign, plottype = 6)
  reactiveDesignVars$boundplot <- plot.gsDesign(testDesign, plottype = 3)
  reactiveDesignVars$fulldesign <- testDesign
  reactiveDesignVars$table$timing <- testDesign$timing
  reactiveDesignVars$table$samples <- testDesign$n.I * 2
  reactiveDesignVars$table$lower <- testDesign$lower$bound
  reactiveDesignVars$table$upper <- testDesign$upper$bound
  
    # Evaluate results for boundary crossing
  if (length(reactiveResultsVars$rslt) > 0) {
    for (i in 1:length(reactiveResultsVars$rslt)) {
      d <- reactiveResultsVars$rslt[i]
      a <- as.numeric(d[[1]][1])
      b <- d[[1]][6]
      if (b > reactiveDesignVars$table$upper[a]) {
        reactiveResultsVars$win <-
          list(checkpoint = a, outcome = "efficacy")
        break
      } else if (b < reactiveDesignVars$table$lower[a]) {
        reactiveResultsVars$win <-
          list(checkpoint = a, outcome = "futility")
      }
    }
  }
})

output$fixedN <- renderText({round(reactiveDesignVars$fixedn)})
output$fixedDays <- renderText({round(reactiveDesignVars$fixedn/(input$traff/input$dayNum))})
output$seqN <- renderText({round(reactiveDesignVars$seqn)})
output$maxDays <- renderText({round(reactiveDesignVars$seqn/(input$traff/input$dayNum))})
output$diff <- renderText({round((reactiveDesignVars$seqn/reactiveDesignVars$fixedn-1)*100)})
# Probably need to make the plot a UI output so can be customized/styled in here better
output$pwrPlot <- renderPlot(reactiveDesignVars$pwrplot, height = 350)
output$deltaPlot <- renderPlot(reactiveDesignVars$deltaplot, height = 350)
output$boundPlot <- renderPlot(reactiveDesignVars$boundplot, height = 350)
output$fulldesign <- renderPrint(reactiveDesignVars$fulldesign)

```

### Sample size comparison

```{r samples}
div(
  h5("Fixed-horizon sample size: ",
     strong(textOutput("fixedN", inline = TRUE)),
     " (Estimated ",
     strong(textOutput("fixedDays", inline = TRUE)),
     " days)")
)

div(
  h5("Sequential test maximum sample size: ",
     strong(textOutput("seqN", inline = TRUE)),
     " (Estimated ",
     strong(textOutput("maxDays", inline = TRUE)),
     " days)")
)

div(
  h5("That's a maximum increase of ",
     strong(textOutput("diff", inline = TRUE)),
     strong("% "),
     " This is most likely to occur if the true effect size is between H0 and H1.")
)

```


Row {data-height=400}
-----------------------------
### Power analysis
Power chart input here
```{r}
#div(verbatimTextOutput("fulldesign"))
div(plotOutput("pwrPlot"))
```

### Sample size by delta
Chart showing the requisite sample size by difference in cvrs
```{r}
plotOutput("deltaPlot")
```

Row  {data-height=700}
-----------------------------

### Enter results

#### Control Experience
```{r}
div(class='cent',
  h5(class='three-c',
      'Conversions'),
  h5(class='three-c',
      'Visitors'),
  h5(class='three-c',
      'Conversion rate')
)

div(class='cent',
  div(class='three-c',
      numericInput("aConversions", label = NULL, value = "100", step = 10)
      ),
  div(class='three-c',
      numericInput("aTraffic", label = NULL, value = "1000", step = 100)
      ),
  div(class='three-c',
      textOutput("aRate", inline = TRUE)
      )
)

```

#### Test Experience 
```{r}
div(
  class = 'cent',
  h5(class = 'three-c',
     'Conversions'),
  h5(class = 'three-c',
     'Visitors'),
  h5(class = 'three-c',
     'Conversion rate')
)

div(
  class = 'cent',
  div(class = 'three-c',
      numericInput(
        "bConversions", label = NULL, value = "110", step = 10
      )),
  div(class = 'three-c',
      numericInput(
        "bTraffic", label = NULL, value = "1000", step = 100
      )),
  div(class = 'three-c',
      textOutput("bRate", inline = TRUE))
)

```

#### Calculations 
```{r}
div(class = 'cent',
    h5(class = 'three-c',
       'Delta'),
    h5(class = 'three-c',
       'Z-score'),
    h5(class = 'three-c',
           '% of Sample size'))

div(class = "cent",
    div(class = "big three-c",
        textOutput("rateDiff")),
    div(class = "big three-c",
        textOutput("zscore")),
    div(class = "big three-c",
        textOutput("proportion")))
```

#### Checkpoint select - enter the results for the right checkpoint
```{r}
div(class = "cent",
    div(class = "two-c", htmlOutput("checkSelect")),
    div(class = "two-c", actionLink("addResults", "Add checkpoint results")))
```

```{r resultsOutputs, include=FALSE}
output$checkSelect <- renderUI({
  sliderInput("checkpoint",
              NULL,
              min = 1, 
              max = input$checknum,
              value = 1,
              step = 1,
              round = TRUE,
              ticks = FALSE,
              pre = "Checkpoint number: ")
})

output$bRate <- renderText({input$bConversions / input$bTraffic})

output$aRate <- renderText({input$aConversions / input$aTraffic})

output$rateDiff <- renderText({
  req(input$aConversions > 1)
  req(input$bConversions > 1)
  req(input$aTraffic > 10)
  req(input$bTraffic > 10)
  
  diff <-
    round(((input$bConversions / input$bTraffic) / (input$aConversions / input$aTraffic) -
             1
    ) * 100, 2)
  paste0(diff, "%")
})


observeEvent(c(input$aConversions, input$bConversions, input$aTraffic, input$bTraffic),{
  req(input$aConversions > 1)
  req(input$bConversions > 1)
  req(input$aTraffic > 10)
  req(input$bTraffic > 10)
  
  a <- input$aConversions
  b <- input$bConversions
  c <- input$aTraffic
  d <- input$bTraffic
  e <- if (input$tls == 3) input$nonf/100 else 0
  
  reactiveResultsVars$z <- getz(a,b,c,d,e)
  
})

output$zscore <- renderText({
  req(reactiveResultsVars$z != 0)
  reactiveResultsVars$z})

output$proportion <- renderText({
  req(input$aConversions > 1)
  req(input$bConversions > 1)
  req(input$aTraffic > 10)
  req(input$bTraffic > 10)
  nprop <- (round(100*(input$aTraffic + input$bTraffic)/reactiveDesignVars$seqn))
  paste0(nprop,"%")
  })

observeEvent(input$addResults, {
  rownum <- paste0("checkpoint",input$checkpoint)
  zadd <- reactiveResultsVars$z
  rsltList <- c(input$checkpoint,input$aConversions,input$aTraffic,input$bConversions,input$bTraffic,zadd)
  
  reactiveResultsVars$rslt[[rownum]] <- rsltList
  


})

observeEvent(input$checkpoint, {
  try({
  for (i in 1:length(reactiveResultsVars$rslt)) {
      d <- reactiveResultsVars$rslt[i]
      a <- d[[1]][1]
      if (!is.null(a) && a == input$checkpoint) {
        updateNumericInput(session,"aConversions", value = d[[1]][2])
        updateNumericInput(session,"aTraffic", value = d[[1]][3])
        updateNumericInput(session,"bConversions", value = d[[1]][4])
        updateNumericInput(session,"aTraffic", value = d[[1]][5])
      }
  }
  })
}, ignoreInit = TRUE)

```


### Result analysis
```{r tableOutput, include=FALSE}
output$resultTable <- renderTable({
  results <- data.frame(
    times = reactiveDesignVars$table$timing,
    samples = reactiveDesignVars$table$samples,
    lower = reactiveDesignVars$table$lower,
    upper = reactiveDesignVars$table$upper,
    results = 0
  )
  
  try({
    for (i in 1:length(reactiveResultsVars$rslt)) {
      d <- reactiveResultsVars$rslt[i]
      a <- d[[1]][1]
      b <- d[[1]][6]
      results[a, 5] = b
    }
  })
  
  
  results
}) 
```

```{r}
div(class="table", tableOutput("resultTable"))
```

#### Test outcome
```{r}
div(class = "big",
  textOutput("outcome")
)
div(class = "big",
  textOutput("confidence")
)
div(class = "big",
  textOutput("interval")
)
```

Click carefully 
```{r}
div(
  actionLink("clear","Clear all results")
)
```

```{r clearResults, include=FALSE}
observeEvent(input$clear, {
  req(!is.null(reactiveResultsVars$rslt))
  
  reactiveResultsVars$rslt <- NULL
  reactiveResultsVars$win <- NULL
}, ignoreInit = TRUE)
```


```{r}
div(class="table", plotOutput("boundPlot"))
```

```{r confidenceCalcFunction, include=FALSE}

calcConfidence <- function(Ns, Zs, xA, xB, nA, nB, ciZ, tls) {
  # Ns is list of sample sizes at check-ins, these are for 1 variation, not total
  # Zs are the upper boundary z scores for all prior check-ins and the calculated z score for the last one
  # xA is number of conversions in control
  # xB is number of conversions in test
  # nA is number of samples in control
  # nB is number of samples in test
  # ciZ is the upper boundary z score for the final check in point
  # tls number of tails
  
  
  # Adjusted p-value once a critical boundary has been crossed
  probs <- gsProbability(k=length(Ns), theta=0, n.I=Ns, a=array(-20,length(Ns)),b=Zs)
  
  pval <- sum(probs$upper$prob) * tls

  conf <- abs(round((1-pval)*100, digits=1))
  textConf <- paste0(conf,'%')
  
  # Compute adjusted CI 
  ci <- ciBinomial(x1=xB, x2=xA, n1=nB, n2=nA,
                   alpha=2*(1-pnorm(ciZ)))

  ci$lower <- round(ci$lower/(xA/nA)*100, digits=1)
  ci$upper <- round(ci$upper/(xA/nA)*100, digits=1)
  
  textLci <- paste0(ci$lower,'%')
  textUci <- paste0(ci$upper,'%')
  
  ciPayload <- list(textConf, textLci, textUci)
  
  return(
    ciPayload
    )
}

observeEvent(reactiveResultsVars$win$outcome, {
  req(reactiveResultsVars$win$outcome == "efficacy")
  
  checkNum <- paste0("checkpoint",reactiveResultsVars$win$checkpoint)
  checkNumInt <- reactiveResultsVars$win$checkpoint
  nList <- reactiveDesignVars$table$samples/2
  winZ <- reactiveResultsVars$rslt[[checkNum]][6]
  Ns <- if (checkNumInt == 1) nList[1] else c(nList[1:checkNumInt])# Ns is list of sample sizes at check-ins, these are for 1 variation, not total
  Zs <- if (checkNumInt == 1) winZ else c(reactiveDesignVars$table$upper[1:(checkNumInt-1)],winZ) # upper boundary z-scores from test design up to most recent check-in, original z-scores for all but the most recent which is calculated z-score 
  xA <- reactiveResultsVars$rslt[[checkNum]][2] # number of conversions in control
  xB <- reactiveResultsVars$rslt[[checkNum]][4] # number of conversions in test
  nA <- reactiveResultsVars$rslt[[checkNum]][3] # number of samples in control
  nB <- reactiveResultsVars$rslt[[checkNum]][5] # number of samples in test
  ciZ <- reactiveDesignVars$table$upper[checkNumInt] # upper boundary z-score from original design for the most recent check-in point
  tls <- reactiveDesignVars$tls # tls number of tails

  ciCalc <- calcConfidence(Ns,Zs,xA,xB,nA,nB,ciZ,tls)
  
  reactiveResultsVars$win$conf <- ciCalc[1]
  reactiveResultsVars$win$ciLow <- ciCalc[2]
  reactiveResultsVars$win$ciHigh <- ciCalc[3]

}, ignoreInit = TRUE)

output$outcome <- renderText({
  req(!is.null(reactiveResultsVars$win))
  
  reactiveResultsVars$win$outcome
})

output$confidence <- renderText({
  req(!is.null(reactiveResultsVars$win$conf))
  
  reactiveResultsVars$win$conf
})

output$confidence <- renderText({
  req(!is.null(reactiveResultsVars$win$ciLow))
  
  paste("Estimated difference = ",reactiveResultsVars$win$ciLow," - ",reactiveResultsVars$win$ciHigh)
})
```

Row
-----------------------------
Thanks for coming, [leave us feedback](https://docs.google.com/forms/d/e/1FAIpQLSfHiI150WWY1cTTE1UaKHKuNxoeL9zxck1v-UZWRkWl1eVsQw/viewform).

Row
-----------------------------
### Reference material
```{r calculations, include=FALSE}
# 
#   # DATA TABLE ----
#   # Creates a table of key data from the design output
#   designSum <- data.frame(
#     finalDesign$timing,
#     finalDesign$n.I * 2,
#     finalDesign$lower$bound,
#     finalDesign$upper$bound
#   )
#   
#   # PVALUES ----
#   # Adds pvalues and formats the table a bit
#   names(designSum) <- c('checkPct','checkN','lowerZ','upperZ')
#   designSum$'checkPct' <- percent(designSum$'checkPct', 0)
#   designSum$'lowerZ' <- round(designSum$'lowerZ', digits = 2)
#   designSum$'upperZ' <- round(designSum$'upperZ', digits = 2)
#   designSum$'upperPval' <- round(1-pnorm(designSum$'upperZ'), digits = 4)
#   designSum$'lowerPval' <- round(1-pnorm(designSum$'lowerZ'), digits = 4)
# 
#   
#   # PAYLOAD ----
#   # compiles final payload
#   payload <-  list(designSum, finalDesign, n_fixed, n_sequential, testChange)
#   
#   return(
#     payload
#   )
# 
# 
# 
# testResults <- data.frame()
#   fixedInt <- 0
#   zlist <- c()
#   nlist <- c()
#   ilist <- c()
#   cvsAlist <- c()
#   cvsBlist <- c()
#   nAlist <- c()
#   nBlist <- c()
#   nonfM <- 0
#   
# 
#       # FORMAT OUTPUTS ----
#       # formats sample outputs before going into the outputs
#       fixed <- design[[3]] * 2
#       fixed <- comma(fixed, digits = 0)
#       seq <- design[[4]] * 2
#       seq <- comma(seq, digits = 0)
#       n1 <- paste0('Fixed-horizon sample size:  ', fixed)
#       n2 <- paste0('Sequential max sample size: ', seq)
#       n3 <- paste0('Max increase: ', design[[5]], '%')
#       
#       # SAMPLE OUTPUTS ----
#       #output$fixedn <- renderText(paste(fixed))
#       output$sequentialn <- renderText(paste(n1, n2, n3, sep = "\n"))
#       #output$nchange <- renderText(paste(design[[5]], '%'))
#       
#     
#       # TABLE OUTPUT ----
#       tbl1 <- as.data.frame(design[[1]])
#       tbl1$checkN <- comma(tbl1$checkN, digits = 0)
#       
#       daysList <- c()
#       daysIndex <- 1
#       for (i in tbl1$checkN) {
#         daysList[daysIndex] <- paste(ceiling(tbl1$checkN[daysIndex] / (input$traff / 7)),'Days')
#         daysIndex <- daysIndex + 1
#       }
#       tbl1$days <- daysList
#       tbl1 <- tbl1[,c('checkPct','checkN','days','lowerZ','upperZ')]
# 
#       tbl1$checkPct <- lapply(tbl1$checkPct, as.character)
#       tbl1$checkN <- lapply(tbl1$checkN, as.character)
#       
#       names(tbl1) <-
#         c('% of Test',
#           'Total Sample',
#           'Est. Days',
#           'Lower Z-score',
#           'Upper Z-score')
#           #'Upper Pval',
#           #'Lower Pval',
#           
#       
#       
#       #output$table <- renderPrint(tbl1)
#       
#       #tbl2 <- tbl1
#       
#       
#       output$seqTable <- renderTable(tbl1, 
#                                      digits = c(0,0,0,0,2,2), 
#                                      align = 'c', 
#                                      hover = TRUE, 
#                                      display = c('d','s','s','s','f','f'),
#                                      width = '100%'
#                                      )
#       
#       
#       
#       # OUTCOME CHECK ----
#       # na, inconclusive, win, lose
#       
#       rsltsRows <- nrow(testResults)
#       
#       if (rsltsRows < 1) {
#         outcome <- "na"
#         
#       } else if (testResults[rsltsRows,'zscores']>design[[1]]$upperZ[rsltsRows]) {
#         outcome <- "winner"
# 
#       } else if (testResults[rsltsRows,'zscores']<design[[1]]$lowerZ[rsltsRows]) {
#         outcome <- "loser"
#         
#       } else {
#         outcome <- "inconclusive"
#       }
# 
#       
#       # ZSCORE PLOT ----
#       output$bounds <- renderPlot({
#         designPlot(design[[1]], testResults, outcome) 
# 
#       })
#     
#     
#   
# 
#   # DESIGN PLOT FUNCTION ----
#   designPlot <- function(seqTable, rsltsDf, outcome) {
#     lim1 <- head(seqTable$checkN,1)/4
#     lim2 <- tail(seqTable$checkN,1)+lim1
#     rsltsRows <- nrow(rsltsDf)
#     
#     seqPlot <- ggplot(
#       seqTable, 
#       aes(checkN),
#       size = 8
#     ) + geom_line(
#       mapping = aes(y = upperZ),
#       color = '#456990',
#       size = 1.25,
#       stat = "identity"
#     ) + geom_line(
#       mapping = aes(y = lowerZ),
#       stat = "identity",
#       color = '#e95420',
#       size = 1.25
#     ) + labs(
#       x = "Sample Size",
#       y = "Z-score"
#     ) + geom_text(
#       mapping = aes(x = checkN, y = lowerZ, label = lowerZ),
#       size = 5.5,
#       nudge_y = -.2
#     ) + geom_text(
#       mapping = aes(x = checkN, y = upperZ, label = upperZ),
#       size = 5.5,
#       nudge_y = .2
#     ) + geom_point(
#       mapping = aes(x = checkN, y = lowerZ),
#       colour = "#e95420",
#       shape = 20,
#       size = 3
#     ) + geom_point(
#       mapping = aes(x = checkN, y = upperZ),
#       colour = "#456990",
#       shape = 20,
#       size = 3
#     ) +  scale_x_continuous(
#       breaks = comma(seqTable$checkN, digits = 0)
#     ) + coord_cartesian(
#       expand = TRUE, 
#       clip = "off"
#     ) + theme_light(
#       base_size = 16
#     ) + theme(
#       text = element_text(family = 'mono', face = "plain")
#     ) + theme(
#       axis.title.x = element_text(vjust = -0.99)
#     ) + theme(
#       panel.grid.minor.x = element_blank()
#     ) + theme(
#       plot.background = element_rect(fill = "#FCFCFC")
#     ) 
#     
#     
#     rsltsLayers <- list(
#       geom_point(data = rsltsDf,
#                  mapping = aes(samples, zscores),
#                  color = '#49beaa',
#                  stat = "identity"
#       ), geom_text(data = rsltsDf,
#                    mapping = aes(samples, zscores, label = zscores),
#                    size = 5,
#                    colour = "#3c362a",
#                    nudge_y = .3
#                    )
# 
#     )
#     
#     rsltsLine <- list(
#       geom_line(data = rsltsDf,
#                              mapping = aes(samples, zscores),
#                              stat = "identity",
#                              color = '#49beaa',
#                              size = 1.25
#                 )
#     )
#     
#    
#     
#     loser <- list(
#       geom_text(
#         mapping = aes(x=lim2, y=lowerZ[1]-1, label="Boundary crossed", family="mono"),
#         size = 7,
#         hjust = 1,
#         colour = "#49beaa"
#       )
#     )
#     
#       loser2tail <- list(
#         geom_text(
#           mapping = aes(x=lim2, y=lowerZ[1] - 1.5, label=paste0('Confidence Level: ',adjCi[1]), family="mono"),
#           size = 5,
#           hjust = 1,
#           colour = "#3c362a"
#       ), 
#       geom_text(
#         mapping = aes(x=lim2, y=lowerZ[1] - 1.9, label=paste0('Confidence Interval: ',adjCi[2], ' - ', adjCi[3]), family="mono"),
#         size = 5,
#         hjust = 1,
#         colour = "#3c362a"
#       ))
#     
#     winner <- list(
#       geom_text(
#         mapping = aes(x=lim2, y=upperZ[1]+2, label="Boundary crossed", family="mono"),
#         size = 7,
#         hjust = 1,
#         colour = "#49beaa"
#       ),
#       geom_text(
#         mapping = aes(x=lim2, y=upperZ[1] + 1.5, label=paste0('Confidence Level: ',adjCi[1]), family="mono"),
#         size = 5,
#         hjust = 1,
#         colour = "#3c362a"
#       ),
#       geom_text(
#         mapping = aes(x=lim2, y=upperZ[1] + 1.1, label=paste0('Confidence Interval: ',adjCi[2], ' - ', adjCi[3]), family="mono"),
#         size = 5,
#         hjust = 1,
#         colour = "#3c362a"
#       ) 
#     )
#     
#     
#     
#     if (length(rsltsDf)>0) {
#       seqPlot <- seqPlot + rsltsLayers
#       
#       if (nrow(rsltsDf)>1) {
#         seqPlot <- seqPlot + rsltsLine
#       }
#       
#       if(outcome == 'winner') {
#         seqPlot <- seqPlot + winner
#       } else if (outcome == 'loser' && input$tls > 1) {
#         seqPlot <- seqPlot + loser + loser2tail
#       } else if (outcome == 'loser') {
#         seqPlot <- seqPlot + loser
#       }
#       
#     } 
#     seqPlot
#   }
#   


```


